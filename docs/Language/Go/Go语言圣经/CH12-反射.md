# CH12.反射

---

- [CH12.反射](#ch12反射)
  - [CH12.1.为何需要反射](#ch121为何需要反射)
  - [CH12.2.reflect.Type 和 reflect.Value](#ch122reflecttype-和-reflectvalue)
    - [reflect.Type](#reflecttype)
    - [reflect.Value](#reflectvalue)
  - [CH12.3. Display，一个递归的值打印器](#ch123-display一个递归的值打印器)
  - [CH12.4. 示例: 编码为S表达式](#ch124-示例-编码为s表达式)
  - [CH12.5. 通过reflect.Value修改值](#ch125-通过reflectvalue修改值)
  - [CH12.6. 示例: 解码S表达式](#ch126-示例-解码s表达式)
  - [CH12.7. 获取结构体字段标签](#ch127-获取结构体字段标签)
  - [CH12.8. 显示一个类型的方法集](#ch128-显示一个类型的方法集)
  - [CH12.9. 几点忠告](#ch129-几点忠告)

---

> [反射 - Go语言圣经 (golang-china.github.io)](https://golang-china.github.io/gopl-zh/ch12/ch12.html)

在Go语言中，反射（Reflection）是一种强大的工具，它允许程序在运行时检查和操作变量的类型和值。反射使得代码能够在编译时未知的情况下操作不同类型的数据。Go语言中的反射主要通过标准库中的`reflect`包来实现。

在本章，我们将探讨Go语言的反射特性，看看它可以给语言增加哪些表达力，以及在两个至关重要的API是如何使用反射机制的：

- 一个是fmt包提供的字符串格式化功能
- 另一个是类似 `encoding/json` 和 `encoding/xml` 提供的针对特定协议的编解码功能。

对于我们在4.6节中看到过的 `text/template` 和 `html/template` 包，它们的实现也是依赖反射技术的。然后，反射是一个复杂的内省技术，不应该随意使用，因此，尽管上面这些包内部都是用反射技术实现的，但是它们自己的API都没有公开反射相关的接口。

---

反射在Go语言中非常有用，尤其是在需要编写通用库、框架或需要处理未知类型的情况下。不过，反射也带来了性能开销和代码的复杂性，因此在使用时需要谨慎。

如下是一个示例, 展示了如何使用反射来获取类型和值、获取变量的基本类型、通过反射修改值，以及如何操作结构体的字段。

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	// 示例1：获取类型和值
	var x float64 = 3.4
	fmt.Println("type:", reflect.TypeOf(x))   // type: float64
	fmt.Println("value:", reflect.ValueOf(x)) // value: 3.4

	// 示例2：获取Kind
	fmt.Println("kind:", reflect.TypeOf(x).Kind()) // kind: float64

	// 示例3：通过反射修改值
	y := 7
	v := reflect.ValueOf(&y) // 传递指针
	v.Elem().SetInt(42)
	fmt.Println("new value:", y) // new value: 42

	// 示例4：操作结构体字段
	type T struct {
		A int
		B string
	}
	t := T{203, "hello"}
	s := reflect.ValueOf(&t).Elem()
	typeOfT := s.Type()

	// 0: A int = 203
	// 1: B string = hello
	for i := 0; i < s.NumField(); i++ {
		f := s.Field(i)
		fmt.Printf("%d: %s %s = %v\n", i, typeOfT.Field(i).Name, f.Type(), f.Interface())
	}

	s.Field(0).SetInt(999)
	s.Field(1).SetString("world")
	fmt.Println("new struct:", t) // new struct: {999 world}
}

```

> ![image-20240730020939137](http://cdn.ayusummer233.top/DailyNotes/202407300209215.png)

一些Go语言反射中的关键概念

**Type和Value**：

- `reflect.Type`：表示一个Go类型，可以使用`reflect.TypeOf`函数获取。
- `reflect.Value`：表示一个Go值，可以使用`reflect.ValueOf`函数获取。

**Kind**：

- `reflect.Kind`表示Go语言的基本类型，比如`int`、`float64`、`slice`、`struct`等。`Kind`可以帮助我们知道某个值属于哪种基础类型，而不关注具体的类型细节。
- 可以通过`reflect.Type`的`Kind`方法来获取。

**修改值**：

- 要使用反射修改变量的值，必须是可设置的（settable）。一般需要传递变量的指针。
- 使用`reflect.Value`的`Set`方法来修改值。

**检查和操作结构体字段和方法**：

- 可以通过反射来检查结构体的字段和方法，并进行相应的操作。

----

## CH12.1.为何需要反射

> [为何需要反射? - Go语言圣经 (golang-china.github.io)](https://golang-china.github.io/gopl-zh/ch12/ch12-01.html)

有时候我们需要编写一个函数能够处理一类并不满足普通公共接口的类型的值，也可能是因为它们并没有确定的表示方式，或者是在我们设计该函数的时候这些类型可能还不存在。

一个大家熟悉的例子是 `fmt.Fprintf` 函数提供的字符串格式化处理逻辑，它可以用来对任意类型的值格式化并打印，甚至支持用户自定义的类型。

让我们也来尝试实现一个类似功能的函数。为了简单起见，我们的函数只接收一个参数，然后返回和 `fmt.Sprint` 类似的格式化后的字符串。我们实现的函数名也叫 `Sprint`。

我们首先用 switch 类型分支来测试输入参数是否实现了 String 方法，如果是的话就调用该方法。然后继续增加类型测试分支，检查这个值的动态类型是否是 `string`、`int`、`bool` 等基础类型，并在每种情况下执行相应的格式化操作。

```go
// 函数接收一个空接口类型 interface{} 的参数 x，这意味着它可以接受任何类型的值。
func Sprint(x interface{}) string {
    type stringer interface {
        String() string
    }
    switch x := x.(type) {
    case stringer:
        return x.String()
    case string:
        return x
    case int:
        return strconv.Itoa(x)
    // ...similar cases for int16, uint32, and so on...
    case bool:
        if x {
            return "true"
        }
        return "false"
    default:
        // array, chan, func, map, pointer, slice, struct
        return "???"
    }
}

```

但是我们如何处理其它类似 `[]float64`、``map[string][]string`等类型呢？

我们当然可以添加更多的测试分支，但是这些组合类型的数目基本是无穷的。

还有如何处理类似 `url.Values` 这样的具名类型呢？即使类型分支可以识别出底层的基础类型是 `map[string][]string`，但是它并不匹配 `url.Values` 类型，因为它们是两种不同的类型，而 且switc h类型分支也不可能包含每个类似 `url.Values` 的类型，这会导致对这些库的依赖。

没有办法来检查未知类型的表示方式，我们被卡住了。这就是我们需要反射的原因。

---

## CH12.2.reflect.Type 和 reflect.Value

> [reflect.Type和reflect.Value - Go语言圣经 (golang-china.github.io)](https://golang-china.github.io/gopl-zh/ch12/ch12-02.html)

反射是由 reflect 包提供的。它定义了两个重要的类型，Type 和 Value。

---

### reflect.Type

一个 Type 表示一个Go类型。它是一个接口，有许多方法来区分类型以及检查它们的组成部分，例如一个结构体的成员或一个函数的参数等。唯一能反映 `reflect.Type` 实现的是接口的类型描述信息（§7.5），也正是这个实体标识了接口值的动态类型。

函数 `reflect.TypeOf` 接受任意的 `interface{}` 类型，并以 `reflect.Type` 形式返回其动态类型：

```go
t := reflect.TypeOf(3)  // a reflect.Type
fmt.Println(t.String()) // "int"
fmt.Println(t)          // "int"
```

其中 `TypeOf(3)` 调用将值 3 传给 `interface{}` 参数。

回到 7.5节 的将一个具体的值转为接口类型会有一个隐式的接口转换操作，它会创建一个包含两个信息的接口值：

- 操作数的动态类型（这里是 int）
- 它的动态的值（这里是 3）

因为 `reflect.TypeOf` 返回的是一个动态类型的接口值，它总是返回具体的类型。因此，下面的代码将打印 `*os.File` 而不是 `io.Writer`。稍后，我们将看到能够表达接口类型的 `reflect.Type`。

```go
var w io.Writer = os.Stdout
fmt.Println(reflect.TypeOf(w)) // "*os.File"
```

> ![image-20240730023221373](http://cdn.ayusummer233.top/DailyNotes/202407300232411.png)
>
> ![image-20240730023232431](http://cdn.ayusummer233.top/DailyNotes/202407300232462.png)

---

要注意的是 `reflect.Type` 接口是满足 `fmt.Stringer` 接口的。因为打印一个接口的动态类型对于调试和日志是有帮助的， `fmt.Printf` 提供了一个缩写 `%T` 参数，内部使用 `reflect.TypeOf` 来输出：

```go
fmt.Printf("%T\n", 3) // "int"
```

---

### reflect.Value

`reflect` 包中另一个重要的类型是 Value。一个 `reflect.Value` 可以装载任意类型的值。

函数 `reflect.ValueOf` 接受任意的 `interface{}` 类型，并返回一个装载着其动态值的 `reflect.Value`。

和 `reflect.TypeOf` 类似，`reflect.ValueOf` 返回的结果也是具体的类型，但是 `reflect.Value` 也可以持有一个接口值。

```
var w io.Writer = os.Stdout
fmt.Println(reflect.TypeOf(w)) // "*os.File"

fmt.Printf("%T\n", 3) // "int"

v := reflect.ValueOf(3) // a reflect.Value
//  fmt.Println 函数会自动调用 reflect.Value 的 String 方法，该方法对基本类型（如 int）进行特殊处理，返回其字符串表示形式。 "3"
fmt.Println(v)
fmt.Printf("%v\n", v) // %v 是 Go 语言中的通用占位符，它会调用 v 的 String 方法，输出结果同样为 "3"
// v.String() 明确调用了 reflect.Value 类型的 String 方法。对于 reflect.Value 类型，这个方法返回的是值的描述信息，而不是被封装的值本身
fmt.Println(v.String()) // NOTE: "<int Value>"
```

和 `reflect.Type` 类似，``reflect.Value` 也满足 `fmt.Stringer` 接口，但是除非 Value 持有的是字符串，否则 String 方法只返回其类型。而使用 fmt 包的 %v 标志参数会对 `reflect.Values` 特殊处理。

对 Value 调用 Type 方法将返回具体类型所对应的 `reflect.Type`：

```go
t := v.Type()           // a reflect.Type
fmt.Println(t.String()) // "int"
```

`reflect.ValueOf` 的逆操作是 `reflect.Value.Interface` 方法。它返回一个 `interface{}` 类型，装载着与 `reflect.Value` 相同的具体值：

```go
v := reflect.ValueOf(3) // a reflect.Value
x := v.Interface()      // an interface{}
i := x.(int)            // an int
fmt.Printf("%d\n", i)   // "3"
```

`reflect.Value` 和  `interface{}` 都能装载任意的值。所不同的是:

- 一个空的接口隐藏了值内部的表示方式和所有方法，因此只有我们知道具体的动态类型才能使用类型断言来访问内部的值（就像上面那样），内部值我们没法访问。
- 相比之下，一个 Value 则有很多方法来检查其内容，无论它的具体类型是什么。

让我们再次尝试实现我们的格式化函数 format.Any。

我们使用 `reflect.Value` 的 Kind 方法来替代之前的类型 switch。虽然还是有无穷多的类型，但是它们的 kinds 类型却是有限的：Bool、String 和 所有数字类型的基础类型；Array 和 Struct 对应的聚合类型；Chan、Func、Ptr、Slice 和 Map 对应的引用类型；interface 类型；还有表示空值的 Invalid 类型。（空的 reflect.Value 的 kind 即为 Invalid。）

`ch12/format`

```go
package format

import (
    "reflect"
    "strconv"
)

// Any formats any value as a string.
func Any(value interface{}) string {
    return formatAtom(reflect.ValueOf(value))
}

// formatAtom formats a value without inspecting its internal structure.
func formatAtom(v reflect.Value) string {
    switch v.Kind() {
    case reflect.Invalid:
        return "invalid"
    case reflect.Int, reflect.Int8, reflect.Int16,
        reflect.Int32, reflect.Int64:
        return strconv.FormatInt(v.Int(), 10)
    case reflect.Uint, reflect.Uint8, reflect.Uint16,
        reflect.Uint32, reflect.Uint64, reflect.Uintptr:
        return strconv.FormatUint(v.Uint(), 10)
    // ...floating-point and complex cases omitted for brevity...
    case reflect.Bool:
        return strconv.FormatBool(v.Bool())
    case reflect.String:
        return strconv.Quote(v.String())
    case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:
        return v.Type().String() + " 0x" +
            strconv.FormatUint(uint64(v.Pointer()), 16)
    default: // reflect.Array, reflect.Struct, reflect.Interface
        return v.Type().String() + " value"
    }
}

```

到目前为止，我们的函数将每个值视作一个不可分割没有内部结构的物品，因此它叫 `formatAtom`。

对于聚合类型（结构体和数组）和接口，只是打印值的类型，对于引用类型（channels、functions、pointers、slices 和 maps），打印类型和十六进制的引用地址。虽然还不够理想，但是依然是一个重大的进步，并且 Kind 只关心底层表示，``format.Any` 也支持具名类型。例如：

```go
var x int64 = 1
var d time.Duration = 1 * time.Nanosecond
fmt.Println(format.Any(x))                  // "1"
fmt.Println(format.Any(d))                  // "1"
fmt.Println(format.Any([]int64{x}))         // "[]int64 0x8202b87b0"
fmt.Println(format.Any([]time.Duration{d})) // "[]time.Duration 0x8202b87e0"
```

![image-20240730025752847](http://cdn.ayusummer233.top/DailyNotes/202407300257898.png)

![image-20240730025757744](http://cdn.ayusummer233.top/DailyNotes/202407300257791.png)

---

## CH12.3. Display，一个递归的值打印器



----

## CH12.4. 示例: 编码为S表达式





---

## CH12.5. 通过reflect.Value修改值




---

## CH12.6. 示例: 解码S表达式



---

## CH12.7. 获取结构体字段标签




---

## CH12.8. 显示一个类型的方法集




---

## CH12.9. 几点忠告











