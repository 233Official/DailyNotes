# 提纲

## CH1

## CH2 程序结构

### CH2.5 类型

这一节讲了 Go 语言中的类型(type) 概念, 可以使用 `type 类型名字 底层类型` 来定义一个 type

---

然后举了摄氏度华氏度温度转换的例子, 定义了基于 float64 的摄氏度与华氏度类型并编写了二者间的转换函数

从这个示例也引出了当底层类型一致时, 类型之间是可以相互转换的

以及一些其他基本类型强制转换的原则, 例如

- 将一个浮点数转为整数将丢弃小数部分
- 将一个字符串转为`[]byte`类型的slice将拷贝一个字符串数据的副本

又举了如下例子

```go
var c Celsius
var f Fahrenheit
fmt.Println(c == Celsius(f)) // "true"!
```

来演示底层类型相同时的强制类型转换, 不改变值只改变类型

---

对于其中的 `func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }`

`Sprintf` 名字来源于 "String print format", 意思是将格式化的输出打印为字符串返回一个 string 类型的值

在 Go 语言中, 函数和方法是两个不同的概念

- 函数是一段独立的代码, 它可以接收一些参数, 执行一些操作, 然后返回一个或多个结果

  函数不依赖于任何特定的类型或值

  例如 `func Add(a, b int) int` 是一个函数, 它接收两个整数, 返回它们的和

- 方法则是与特定类型关联的函数

  方法的定义方式是在函数名前添加一个参数，这个参数定义了这个方法所属的类型

  例如 `func (c Celsius) String() string` 是一个方法, 它属于 Celsius 类型

  当你在某个类型上定义了方法后, 你就可以在这个类型的值上调用这个方法。例如对于 `c Celsius` 调用 `c.String()` 来获取 `c` 的字符串表示

许多类型都会定义一个 String 方法, 因为当使用 fmt 包的打印方法时，将会优先使用该类型对应的 String 方法返回的结果打印

---

### CH2.6 包和文件

这一节讲了Go 语言中的包和其他语言的库或模块的概念类似, 目的都是为了支持模块化, 封装, 单独编译和代码重用

一个包目录下会有多个 `.go` 源文件, 这些文件中大写字母开头的包级别的类型和常量在同一个包的其他源文件也是可以直接访问的

举了之前提到的摄氏度华氏度温度转换的例子, 把类型定义和转换函数分别放到了两个 go 文件中以展示这些包级别的名字对包内其他源文件也是可见的

此外还用到上一节中提到的每个 type 可以有一个 String 方法用于在使用 fmt 包的打印方法打印 type 实例时输出对应处理后的字符串

---

#### 练习2.1

练习 2.1 练习了包级别名字包内可见, 仿照摄氏度华氏度定义和转换函数编写开尔文温度的定义和转换函数即可

---







