# 提纲

---

- [提纲](#提纲)
	- [CH1](#ch1)
	- [CH2 程序结构](#ch2-程序结构)
		- [CH2.5 类型](#ch25-类型)
		- [CH2.6 包和文件](#ch26-包和文件)
			- [练习2.1](#练习21)
			- [CH2.6.1.导入包](#ch261导入包)
			- [练习2.2](#练习22)
			- [CH2.6.2.包的初始化](#ch262包的初始化)
			- [练习2.3](#练习23)

---

## CH1

## CH2 程序结构

### CH2.5 类型

这一节讲了 Go 语言中的类型(type) 概念, 可以使用 `type 类型名字 底层类型` 来定义一个 type

---

然后举了摄氏度华氏度温度转换的例子, 定义了基于 float64 的摄氏度与华氏度类型并编写了二者间的转换函数

从这个示例也引出了当底层类型一致时, 类型之间是可以相互转换的

以及一些其他基本类型强制转换的原则, 例如

- 将一个浮点数转为整数将丢弃小数部分
- 将一个字符串转为`[]byte`类型的slice将拷贝一个字符串数据的副本

又举了如下例子

```go
var c Celsius
var f Fahrenheit
fmt.Println(c == Celsius(f)) // "true"!
```

来演示底层类型相同时的强制类型转换, 不改变值只改变类型

---

对于其中的 `func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }`

`Sprintf` 名字来源于 "String print format", 意思是将格式化的输出打印为字符串返回一个 string 类型的值

在 Go 语言中, 函数和方法是两个不同的概念

- 函数是一段独立的代码, 它可以接收一些参数, 执行一些操作, 然后返回一个或多个结果

  函数不依赖于任何特定的类型或值

  例如 `func Add(a, b int) int` 是一个函数, 它接收两个整数, 返回它们的和

- 方法则是与特定类型关联的函数

  方法的定义方式是在函数名前添加一个参数，这个参数定义了这个方法所属的类型

  例如 `func (c Celsius) String() string` 是一个方法, 它属于 Celsius 类型

  当你在某个类型上定义了方法后, 你就可以在这个类型的值上调用这个方法。例如对于 `c Celsius` 调用 `c.String()` 来获取 `c` 的字符串表示

许多类型都会定义一个 String 方法, 因为当使用 fmt 包的打印方法时，将会优先使用该类型对应的 String 方法返回的结果打印

---

### CH2.6 包和文件

这一节讲了Go 语言中的包和其他语言的库或模块的概念类似, 目的都是为了支持模块化, 封装, 单独编译和代码重用

一个包目录下会有多个 `.go` 源文件, 这些文件中大写字母开头的包级别的类型和常量在同一个包的其他源文件也是可以直接访问的

举了之前提到的摄氏度华氏度温度转换的例子, 把类型定义和转换函数分别放到了两个 go 文件中以展示这些包级别的名字对包内其他源文件也是可见的

此外还用到上一节中提到的每个 type 可以有一个 String 方法用于在使用 fmt 包的打印方法打印 type 实例时输出对应处理后的字符串

---

#### 练习2.1

练习 2.1 练习了包级别名字包内可见, 仿照摄氏度华氏度定义和转换函数编写开尔文温度的定义和转换函数即可

---

#### CH2.6.1.导入包

这一节主要就是讲了从包外导入包可以 `import 模块名/包路径`, 比如

```go
import (
	"GoLearning/Chapter/ch2/ch2_6_package_and_file/ex2_2/lengthconv"
	"GoLearning/Chapter/ch2/ch2_6_package_and_file/ex2_2/tempconv"
	"GoLearning/Chapter/ch2/ch2_6_package_and_file/ex2_2/weightconv"
	"fmt"
	"os"
	"strconv"
)
```

以及可以在引入包的时候加个别名, 例如:

```go
import alname "GoLearning/Chapter/ch2/ch2_6_package_and_file/ex2_2/lengthconv"
```

---

#### 练习2.2

在原本的温度转换的基础上多写两个长度和重量转换的包, 然后写一个main 函数处理输入并用 switch case 来判断单位以及转换函数即可

新知识也就是 switch case 的语法:

```go
switch s {
case "a":
	// do something
case "b":
	// do something
default:
	// do something
}
```

除此以外还用到了命令行接收的 string 类型的参数可以使用 ` strconv.ParseFloat(number, 64)` 来转换为 float64 类型, 用法类似于前面用到的 `strconv.Atoi` 用于转换整数

```go
number := os.Args[1]
f, err := strconv.ParseFloat(number, 64)
if err != nil {
	fmt.Fprintf(os.Stderr, "%v\n", err)
	os.Exit(1)
}
```

---

#### CH2.6.2.包的初始化

这一节讲了 Go 语言中 package 中初始化的顺序: 

- 首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化
- 如果包中含有多个 `.go` 源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将 `.go` 文件根据文件名排序(字典序)，然后依次调用编译器编译
- 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次, 也就是说当有导入其他包的时候会先初始化其他包
- 每个Go语言的包都可以包含一个或多个init函数。这些函数在包初始化时会自动被调用，无需手动调用。init函数常常被用于执行一些初始化的工作，例如初始化包级别的变量。
- 初始化包级别（全局）的变量后会调用init函数(示例中的 `pc[256]` 即是先初始化为全0，然后调用 `init` 函数将其初始化为一个表)
- 初始化工作是自下而上进行的，main包最后被初始化, 这样可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了

然后举了一个求数字汉明权重的例子, 演示了先初始化全局变量然后调用 init 函数初始化变量的过程


---

#### 练习2.3

练习 2.3 让重写PopCount函数，用一个循环代替单一的表达式。比较两个版本的性能

这里自定义了一个 popcount 包及其 `PopCount` 函数, 然后再 main package 中分别引入这两个自定义的包

这里使用了 

```go
import (
	ex2_3_popcount "GoLearning/Chapter/ch2/ch2_6_package_and_file/ex2_3/popcount"
	popcount "GoLearning/Chapter/ch2/ch2_6_package_and_file/popcount"
	"fmt"
	"time"
)
```

需要注意的是: 和一个包里 `.go` 源程序按照字典序初始化不同, 这里引入的两个包都要先于 `main` 初始化, 但是二者之间没有依赖关系, 无法确定谁先谁后; 这是因为Go语言的设计者选择让包的初始化并行进行，以提高程序启动的速度。因此，如果两个包没有依赖关系，它们可能会在不同的Goroutine中并行初始化，其完成的顺序取决于运行时的调度情况。

这里引入循环会增加额外的开销, 因此单一表达式的版本性能更好; 循环带来的开销可以是:
- **循环控制语句的开销**：每次循环都需要进行条件检查，以确定是否继续执行循环
- **变量更新的开销**：在循环中，通常会有一些变量需要在每次循环时更新（例如循环计数器）
- **函数调用的开销**：如果在循环中调用了函数，那么每次函数调用都会有一定的开销，包括参数传递、返回值处理、栈帧管理等

---







