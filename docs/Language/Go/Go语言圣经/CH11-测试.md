# CH11.测试

> PS: 这章内容读起来也比较丝滑,挺不错的

> [测试 - Go语言圣经 (golang-china.github.io)](https://golang-china.github.io/gopl-zh/ch11/ch11.html)

我们说测试的时候一般是指自动化测试，也就是写一些小的程序用来检测被测试代码（产品代码）的行为和预期的一样，这些通常都是精心设计的执行某些特定的功能或者是通过随机性的输入待验证边界的处理。

Go语言的测试技术是相对低级的。它依赖一个go test测试命令和一组按照约定方式编写的测试函数，测试命令可以运行这些测试函数。编写相对轻量级的纯测试代码是有效的

在实践中，编写测试代码和编写程序本身并没有多大区别。我们编写的每一个函数也是针对每个具体的任务。

---

## CH11.1.go test

> [go test - Go语言圣经 (golang-china.github.io)](https://golang-china.github.io/gopl-zh/ch11/ch11-01.html)

go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以`_test.go`为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。

在`*_test.go`文件中，有三种类型的函数：测试函数、基准测试（benchmark）(性能测试)函数、示例函数。

- 一个测试函数是以Test为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确；go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。

- 基准测试函数是以 `Benchmark` 为函数名前缀的函数，它们用于衡量一些函数的性能；go test命令会多次运行基准测试函数以计算一个平均的执行时间。

- 示例函数是以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档。

我们将在11.2节讨论测试函数的所有细节，并在11.4节讨论基准测试函数的细节，然后在11.6节讨论示例函数的细节。

go test命令会遍历所有的`*_test.go`文件中符合上述命名规则的函数，生成一个临时的main包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。

---

## CH11.2.测试函数

> [测试函数 - Go语言圣经 (golang-china.github.io)](https://golang-china.github.io/gopl-zh/ch11/ch11-02.html)

每个测试函数必须导入testing包。测试函数有如下的签名：

```go
func TestName(t *testing.T) {
    // ...
}
```

测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头：

```go
func TestSin(t *testing.T) { /* ... */ }
func TestCos(t *testing.T) { /* ... */ }
func TestLog(t *testing.T) { /* ... */ }
```

其中 `t` 参数用于报告测试失败和附加的日志信息。

让我们定义一个实例包 `gopl.io/ch11/word1`，其中只有一个函数IsPalindrome用于检查一个字符串是否从前向后和从后向前读都是一样的。（下面这个实现对于一个字符串是否是回文字符串前后重复测试了两次；我们稍后会再讨论这个问题。）

`ch11/word1`

```go
// Package word provides utilities for word games.
package word

// IsPalindrome reports whether s reads the same forward and backward.
// (Our first attempt.)
func IsPalindrome(s string) bool {
    for i := range s {
        if s[i] != s[len(s)-1-i] {
            return false
        }
    }
    return true
}

```

在相同的目录下，`word_test.go` 测试文件中包含了 `TestPalindrome` 和 `TestNonPalindrome` 两个测试函数。每一个都是测试 `IsPalindrome` 是否给出正确的结果，并使用 `t.Error` 报告失败信息：

```go
package word

import "testing"

func TestPalindrome(t *testing.T) {
    if !IsPalindrome("detartrated") {
        t.Error(`IsPalindrome("detartrated") = false`)
    }
    if !IsPalindrome("kayak") {
        t.Error(`IsPalindrome("kayak") = false`)
    }
}

func TestNonPalindrome(t *testing.T) {
    if IsPalindrome("palindrome") {
        t.Error(`IsPalindrome("palindrome") = true`)
    }
}

```

`go test`命令如果没有参数指定包那么将默认采用当前目录对应的包（和`go build`命令一样）。我们可以用下面的命令构建和运行测试。

```bash
go test
```

![image-20240709143615192](http://cdn.ayusummer233.top/DailyNotes/image-20240709143615192.png)

结果还比较满意，我们运行了这个程序， 不过没有提前退出是因为还没有遇到BUG报告。不过一个法国名为“Noelle Eve Elleon”的用户会抱怨IsPalindrome函数不能识别“été”。另外一个来自美国中部用户的抱怨则是不能识别“A man, a plan, a canal: Panama.”。执行特殊和小的BUG报告为我们提供了新的更自然的测试用例。

```go
func TestFrenchPalindrome(t *testing.T) {
    if !IsPalindrome("été") {
        t.Error(`IsPalindrome("été") = false`)
    }
}

func TestCanalPalindrome(t *testing.T) {
    input := "A man, a plan, a canal: Panama"
    if !IsPalindrome(input) {
        t.Errorf(`IsPalindrome(%q) = false`, input)
    }
}

```

![image-20240709143934552](http://cdn.ayusummer233.top/DailyNotes/image-20240709143934552.png)

先编写测试用例并观察到测试用例触发了和用户报告的错误相同的描述是一个好的测试习惯。只有这样，我们才能定位我们要真正解决的问题。

---

先写测试用例的另外的好处是，运行测试通常会比手工描述报告的处理更快，这让我们可以进行快速地迭代。如果测试集有很多运行缓慢的测试，我们可以通过只选择运行某些特定的测试来加快测试速度。

参数`-v`可用于打印每个测试函数的名字和运行时间：

![image-20240709144352425](http://cdn.ayusummer233.top/DailyNotes/image-20240709144352425.png)

---

参数`-run`对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被`go test`测试命令运行：

```bash
go test -v -run="French|Canal"
```

![image-20240709144553407](http://cdn.ayusummer233.top/DailyNotes/image-20240709144553407.png)

---

当然，一旦我们已经修复了失败的测试用例，在我们提交代码更新之前，我们应该以不带参数的`go test`命令运行全部的测试用例，以确保修复失败测试的同时没有引入新的问题。

----

我们现在的任务就是修复这些错误。简要分析后发现第一个BUG的原因是我们采用了 byte而不是rune序列，所以像 `été` 中的 `é` 等非ASCII字符不能正确处理。第二个BUG是因为没有忽略空格和字母的大小写导致的。

> - byte
>
>   - **定义**：`byte`是`uint8`的别名，表示8位无符号整数。
>
>   - **范围**：0到255。
>
>   - **用途**：通常用于处理原始的二进制数据，例如文件I/O、网络通信，以及表示UTF-8编码的字符串中的单个字节。
>
>   `byte`类型的字符串通常用于处理ASCII字符，因为每个字符都可以用一个字节表示。对于UTF-8编码的字符串，每个字符可能由一个或多个字节组成。
>
> - rune
>
>   - **定义**：`rune`是`int32`的别名，表示32位有符号整数。
>
>   - **范围**：$−2^{31}$到 $2^{31−1}$，但通常用于表示Unicode字符，即0到0x10FFFF。
>
>   - **用途**：用于处理Unicode字符，确保每个字符都可以用一个整数表示，即使字符在UTF-8编码中需要多个字节。
>
>   `rune`类型的字符串通常用于处理多字节字符集，确保每个字符都是一个独立的单元，无论其编码长度如何。
>
> 在`byte`循环中，每个字符可能是一个字节，因此对于UTF-8多字节字符（例如中文字符），会显示为不正确的字符（�）。而在`rune`循环中，每个字符都是一个独立的Unicode字符，因此能够正确显示每个字符。

针对上述两个BUG，我们仔细重写了函数：

`ch11/word2`

```go
// Package word provides utilities for word games.
package word

import "unicode"

// IsPalindrome reports whether s reads the same forward and backward.
// Letter case is ignored, as are non-letters.
func IsPalindrome(s string) bool {
    var letters []rune
    for _, r := range s {
        if unicode.IsLetter(r) {
            letters = append(letters, unicode.ToLower(r))
        }
    }
    for i := range letters {
        if letters[i] != letters[len(letters)-1-i] {
            return false
        }
    }
    return true
}

```

同时我们也将之前的所有测试数据合并到了一个测试中的表格中。

```go
func TestIsPalindrome(t *testing.T) {
    var tests = []struct {
        input string
        want  bool
    }{
        {"", true},
        {"a", true},
        {"aa", true},
        {"ab", false},
        {"kayak", true},
        {"detartrated", true},
        {"A man, a plan, a canal: Panama", true},
        {"Evil I did dwell; lewd did I live.", true},
        {"Able was I ere I saw Elba", true},
        {"été", true},
        {"Et se resservir, ivresse reste.", true},
        {"palindrome", false}, // non-palindrome
        {"desserts", false},   // semi-palindrome
    }
    for _, test := range tests {
        if got := IsPalindrome(test.input); got != test.want {
            t.Errorf("IsPalindrome(%q) = %v", test.input, got)
        }
    }
}

```

![image-20240709150046770](http://cdn.ayusummer233.top/DailyNotes/image-20240709150046770.png)

---

这种表格驱动的测试在Go语言中很常见。我们可以很容易地向表格添加新的测试数据，并且后面的测试逻辑也没有冗余，这样我们可以有更多的精力去完善错误信息。

失败测试的输出并不包括调用 `t.Errorf` 时刻的堆栈调用信息。和其他编程语言或测试框架的assert断言不同，`t.Errorf` 调用也没有引起panic异常或停止测试的执行。即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息。

如果我们真的需要停止测试，或许是因为初始化失败或可能是早先的错误导致了后续错误等原因，我们可以使用 `t.Fatal` 或 `t.Fatalf` 停止当前测试函数。它们必须在和测试函数同一个goroutine内调用。

测试失败的信息一般的形式是 `f(x) = y, want z`，其中f(x)解释了失败的操作和对应的输入，y是实际的运行结果，z是期望的正确的结果。就像前面检查回文字符串的例子，实际的函数用于f(x)部分。

显示x是表格驱动型测试中比较重要的部分，因为同一个断言可能对应不同的表格项执行多次。要避免无用和冗余的信息。在测试类似 `IsPalindrome` 返回布尔类型的函数时，可以忽略并没有额外信息的z部分。如果x、y或z是y的长度，输出一个相关部分的简明总结即可。测试的作者应该要努力帮助程序员诊断测试失败的原因。

---

### EX11.1.为4.3节中的charcount程序编写测试。

**练习 11.1:** 为4.3节中的 `charcount` 程序编写测试。

`charcount.go`

```go
// charcount.go
package charcount

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"unicode"
	"unicode/utf8"
)

// CharCount computes counts of Unicode characters from the provided reader.
func CharCount(r io.Reader) (map[rune]int, [utf8.UTFMax + 1]int, int, error) {
	counts := make(map[rune]int)    // counts of Unicode characters
	var utflen [utf8.UTFMax + 1]int // count of lengths of UTF-8 encodings
	invalid := 0                    // count of invalid UTF-8 characters

	in := bufio.NewReader(r)
	for {
		r, n, err := in.ReadRune() // returns rune, nbytes, error
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, utflen, invalid, err
		}
		if r == unicode.ReplacementChar && n == 1 {
			invalid++
			continue
		}
		counts[r]++
		utflen[n]++
	}
	return counts, utflen, invalid, nil
}

func main() {
	counts, utflen, invalid, err := CharCount(os.Stdin)
	if err != nil {
		fmt.Fprintf(os.Stderr, "charcount: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("rune\tcount\n")
	for c, n := range counts {
		fmt.Printf("%q\t%d\n", c, n)
	}
	fmt.Print("\nlen\tcount\n")
	for i, n := range utflen {
		if i > 0 {
			fmt.Printf("%d\t%d\n", i, n)
		}
	}
	if invalid > 0 {
		fmt.Printf("\n%d invalid UTF-8 characters\n", invalid)
	}
}

```

---

`charcount_test.go`

```go
// charcount_test.go
package charcount

import (
	"strings"
	"testing"
	"unicode/utf8"
)

func TestCharCount(t *testing.T) {
	input := "Hello, 世界"
	expectedCounts := map[rune]int{
		'H': 1,
		'e': 1,
		'l': 2,
		'o': 1,
		',': 1,
		' ': 1,
		'世': 1,
		'界': 1,
	}
	expectedUtfLen := [utf8.UTFMax + 1]int{0, 7, 0, 2, 0}

	r := strings.NewReader(input)
	counts, utflen, invalid, err := CharCount(r)
	if err != nil {
		t.Fatalf("CharCount failed: %v", err)
	}

	for r, count := range expectedCounts {
		if counts[r] != count {
			t.Errorf("For rune %q, expected %d but got %d", r, count, counts[r])
		}
	}

	// 判断 x 字节字符数量
	for i, count := range expectedUtfLen {
		if utflen[i] != count {
			t.Errorf("For UTF length %d, expected %d but got %d", i, count, utflen[i])
		}
	}

	if invalid != 0 {
		t.Errorf("Expected 0 invalid characters but got %d", invalid)
	}
}

```

![image-20240709160014708](http://cdn.ayusummer233.top/DailyNotes/image-20240709160014708.png)

---

### CH11.2.1.随机测试

表格驱动的测试便于构造基于精心挑选的测试数据的测试用例。另一种测试思路是随机测试，也就是通过构造更广泛的随机输入来测试探索函数的行为。

那么对于一个随机的输入，我们如何能知道希望的输出结果呢？这里有两种处理策略。第一个是编写另一个对照函数，使用简单和清晰的算法，虽然效率较低但是行为和要测试的函数是一致的，然后针对相同的随机输入检查两者的输出结果。第二种是生成的随机输入的数据遵循特定的模式，这样我们就可以知道期望的输出的模式。

下面的例子使用的是第二种方法：randomPalindrome函数用于随机生成回文字符串。

```go
import "math/rand"

// randomPalindrome returns a palindrome whose length and contents
// are derived from the pseudo-random number generator rng.
func randomPalindrome(rng *rand.Rand) string {
    n := rng.Intn(25) // random length up to 24
    runes := make([]rune, n)
    for i := 0; i < (n+1)/2; i++ {
        r := rune(rng.Intn(0x1000)) // random rune up to '\u0999'
        runes[i] = r
        runes[n-1-i] = r
    }
    return string(runes)
}

func TestRandomPalindromes(t *testing.T) {
    // Initialize a pseudo-random number generator.
    seed := time.Now().UTC().UnixNano()
    t.Logf("Random seed: %d", seed)
    rng := rand.New(rand.NewSource(seed))

    for i := 0; i < 1000; i++ {
        p := randomPalindrome(rng)
        if !IsPalindrome(p) {
            t.Errorf("IsPalindrome(%q) = false", p)
        }
    }
}

```

![image-20240709160341692](http://cdn.ayusummer233.top/DailyNotes/image-20240709160341692.png)

虽然随机测试会有不确定因素，但是它也是至关重要的，我们可以从失败测试的日志获取足够的信息。在我们的例子中，输入 `IsPalindrome` 的p参数将告诉我们真实的数据，但是对于函数将接受更复杂的输入，不需要保存所有的输入，只要日志中简单地记录随机数种子即可（像上面的方式）。有了这些随机数初始化种子，我们可以很容易修改测试代码以重现失败的随机测试。

通过使用当前时间作为随机种子，在整个过程中的每次运行测试命令时都将探索新的随机数据。如果你使用的是定期运行的自动化测试集成系统，随机测试将特别有价值。

----

#### EX11.4.修改randomPalindrome函数

**练习 11.4:** 修改 `randomPalindrome` 函数，以探索 `IsPalindrome` 是否对标点和空格做了正确处理。

可以定义了一个字符集 `charset`，包含字母、空格和标点符号;

在生成回文时从字符集中随机选择字符，包括字母、空格和标点符号，并保证生成的字符串是回文。

```go
package word

import (
	"math/rand"
	"testing"
	"time"
	"unicode"
)

// IsPalindrome reports whether s reads the same forward and backward.
// Letter case is ignored, as are non-letters.
func IsPalindrome(s string) bool {
	var letters []rune
	for _, r := range s {
		if unicode.IsLetter(r) {
			letters = append(letters, unicode.ToLower(r))
		}
	}
	for i := range letters {
		if letters[i] != letters[len(letters)-1-i] {
			return false
		}
	}
	return true
}

// randomPalindrome returns a palindrome whose length and contents
// are derived from the pseudo-random number generator rng.
func randomPalindrome(rng *rand.Rand) string {
	n := rng.Intn(25) // random length up to 24
	runes := make([]rune, n)
	charset := []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,.!?")

	for i := 0; i < (n+1)/2; i++ {
		r := charset[rng.Intn(len(charset))]
		runes[i] = r
		runes[n-1-i] = r
	}

	return string(runes)
}

func TestRandomPalindromes(t *testing.T) {
	// Initialize a pseudo-random number generator.
	seed := time.Now().UTC().UnixNano()
	t.Logf("Random seed: %d", seed)
	rng := rand.New(rand.NewSource(seed))

	for i := 0; i < 1000; i++ {
		p := randomPalindrome(rng)
		if !IsPalindrome(p) {
			t.Errorf("IsPalindrome(%q) = false", p)
		}
	}
}

```

![image-20240709161139347](http://cdn.ayusummer233.top/DailyNotes/image-20240709161139347.png)

---

### CH11.2.2.再测试一个命令

对于测试包`go test`是一个有用的工具，但是稍加努力我们也可以用它来测试可执行程序。如果一个包的名字是 main，那么在构建时会生成一个可执行程序，不过main包可以作为一个包被测试器代码导入。

















---

### CH11.2.3.白盒测试



---

### CH11.2.4.外部测试包



---

### CH11.2.5.编写有效的测试



---

#### EX11.5.用表格驱动的技术扩展TestSplit测试

**练习11.5:** 用表格驱动的技术扩展TestSplit测试，并打印期望的输出结果



---

### CH11.2.6.避免脆弱的测试



---

## CH11.3.测试覆盖率



---

## CH11.4.基准测试



---

### EX11.6.为PopCount函数编写基准测试

**练习 11.6:** 为2.6.2节的练习2.4和练习2.5的PopCount函数编写基准测试。看看基于表格算法在不同情况下对提升性能会有多大帮助。



---

## CH11.5.剖析



---

## CH11.6.示例函数



----



















