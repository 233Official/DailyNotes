import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as p,c as l,a as n,d as e,b as t,e as s}from"./app-BT-bWAve.js";const c={},u=s(`<h1 id="ch8-goroutines和channels" tabindex="-1"><a class="header-anchor" href="#ch8-goroutines和channels"><span>CH8.Goroutines和Channels</span></a></h1><ul><li><a href="#ch8goroutines%E5%92%8Cchannels">CH8.Goroutines和Channels</a><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#81goroutines">8.1.Goroutines</a></li><li><a href="#82-%E7%A4%BA%E4%BE%8B-%E5%B9%B6%E5%8F%91%E7%9A%84clock%E6%9C%8D%E5%8A%A1">8.2. 示例: 并发的Clock服务</a></li></ul></li></ul><hr><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>Go语言中的并发程序可以用两种手段来实现。Goroutine 和 Channel</p><p>Goroutine 和 Channel 是 Go 语言并发编程的核心概念。它们提供了一种高效且易于使用的方式来处理并发任务。</p><p>Goroutine 和 Channel 支持 <code>顺序通信进程”（communicating sequential processes）</code> 或被简称为CSP。CSP是一种现代的并发编程模型，在这种编程模型中值会在不同的运行实例（goroutine）中传递，尽管大多数情况下仍然是被限制在单一实例中。</p><p>​ 第9章覆盖更为传统的并发模型：多线程共享内存，如果你在其它的主流语言中写过并发程序的话可能会更熟悉一些。第9章也会深入介绍一些并发程序带来的风险和陷阱。</p><p>尽管Go对并发的支持是众多强力特性之一，但跟踪调试并发程序还是很困难，在线性程序中形成的直觉往往还会使我们误入歧途。如果这是读者第一次接触并发，推荐稍微多花一些时间来思考这两个章节中的样例。</p><hr><p><strong>Goroutines</strong>是Go语言中的轻量级线程。它们由Go运行时管理，具有以下特点：</p><ol><li><p><strong>轻量级</strong>：相比于传统的线程，Goroutines消耗的资源非常少，一个Goroutine只占用几个KB的内存。</p></li><li><p><strong>简单启动</strong>：使用<code>go</code>关键字很容易启动一个新的Goroutine。例如：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">go</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;main function&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码将并发执行<code>sayHello</code>函数和<code>main</code>函数。</p><blockquote><p>执行后会出现三种输出情况</p><ul><li><img src="http://cdn.ayusummer233.top/DailyNotes/image-20240618105324208.png" alt="image-20240618105324208"></li><li><img src="http://cdn.ayusummer233.top/DailyNotes/image-20240618111048440.png" alt="image-20240618111048440"></li><li><img src="http://cdn.ayusummer233.top/DailyNotes/image-20240618111114045.png" alt="image-20240618111114045"></li></ul></blockquote></li><li><p><strong>并发执行</strong>：Goroutines可以并发执行，这意味着它们可以在“同一时间”执行不同的任务。</p></li><li><p><strong>调度管理</strong>：Goroutines由Go运行时调度，因此程序员无需手动管理线程的创建和销毁。</p></li></ol><hr><p><strong>Channels</strong>是Go语言中用于Goroutines之间通信的机制。它们允许Goroutines安全地交换数据，有以下特点：</p><ol><li><strong>类型化</strong>：Channels是类型化的，这意味着它们只能传递一种特定类型的数据。例如，一个<code>chan int</code>类型的Channel只能传递整数。</li><li><strong>同步</strong>：默认情况下，发送和接收操作是同步的。这意味着发送操作会等待接收操作完成，反之亦然。</li><li><strong>缓冲区</strong>：Channels可以是有缓冲区的，这允许一定数量的数据可以在没有接收者的情况下被发送。</li></ol><p>示例代码：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建一个 string 类型的 Channel</span>
    messages <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>
	<span class="token comment">// 启动一个 Goroutine，向 Channel 发送数据</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        messages <span class="token operator">&lt;-</span> <span class="token string">&quot;ping&quot;</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span>messages
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>main</code>函数创建了一个Channel <code>messages</code>，然后启动一个新的Goroutine向该Channel发送一个字符串<code>&quot;ping&quot;</code>。<code>main</code>函数随后接收并打印该字符串。</p><p>这是一个无缓冲区的 Channel 示例，从运行过程上看具体来说:</p><ul><li>主 Goroutine 运行到 <code>msg := &lt;-messages</code> 并阻塞，等待数据。</li><li>Goroutine 运行到 <code>messages &lt;- &quot;ping&quot;</code> 并阻塞，等待接收者。</li><li>当主 Goroutine 和 Goroutine 都准备好时，数据 <code>&quot;ping&quot;</code> 从 Goroutine 发送到主 Goroutine，两个操作都完成。</li><li>主 Goroutine 接收到数据，继续执行并打印 <code>&quot;ping&quot;</code>。</li></ul><hr><p>有缓冲区的 Channel 示例</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// 有缓冲区的 Channel 示例</span>
<span class="token keyword">func</span> <span class="token function">channelWithBufferExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 创建一个有缓冲的字符串类型的 Channel，缓冲区大小为2</span>
	messages <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>

	<span class="token comment">// 启动一个 Goroutine，向 Channel 发送数据</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		messages <span class="token operator">&lt;-</span> <span class="token string">&quot;Hello, Goroutines!&quot;</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Message sent from Goroutine&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 从 Channel 接收数据并打印</span>
	msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span>messages
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Received message:&quot;</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://cdn.ayusummer233.top/DailyNotes/image-20240618114009866.png" alt="image-20240618114009866"></p><p>运行过程如下：</p><ul><li><p><strong>主 Goroutine 创建 Channel</strong>：创建一个带有缓冲区大小为2的字符串类型的 Channel <code>messages</code>。</p></li><li><p><strong>启动 Goroutine</strong>：Goroutine 启动并尝试向 Channel <code>messages</code> 发送数据 <code>&quot;Hello, Goroutines!&quot;</code>。</p></li><li><p><strong>Goroutine 发送数据到 Channel</strong>：由于 <code>messages</code> Channel 有缓冲区且当前缓冲区为空，发送操作不会阻塞，数据被放入缓冲区，Goroutine 继续执行并打印 <code>&quot;Message sent from Goroutine&quot;</code>。</p></li><li><p><strong>主 Goroutine 从 Channel 接收数据</strong>：主 Goroutine 尝试从 <code>messages</code> Channel 接收数据。</p><p>如果此时缓冲区中已经有数据 <code>&quot;Hello, Goroutines!&quot;</code>，接收操作不会阻塞，主 Goroutine 立即接收到数据并打印 <code>&quot;Received message: Hello, Goroutines!&quot;</code>。如果没有则阻塞等到 Channel 准备好数据则接收。</p></li></ul><hr><h2 id="_8-1-goroutines" tabindex="-1"><a class="header-anchor" href="#_8-1-goroutines"><span>8.1.Goroutines</span></a></h2>`,28),r={href:"https://golang-china.github.io/gopl-zh/ch8/ch8-01.html",target:"_blank",rel:"noopener noreferrer"},d=s(`<p>在Go语言中，每一个并发的执行单元叫作一个goroutine。</p><p>设想这里的一个程序有两个函数，一个函数做计算，另一个输出结果，假设两个函数没有相互之间的调用关系。一个线性的程序会先调用其中的一个函数，然后再调用另一个。如果程序中包含多个goroutine，对两个函数的调用则可能发生在同一时刻。马上就会看到这样的一个程序。</p><p>如果你使用过操作系统或者其它语言提供的线程，那么你可以简单地把goroutine类比作一个线程，这样你就可以写出一些正确的程序了。goroutine和线程的本质区别会在9.8节中讲。</p><p>当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// call f(); wait for it to return</span>
<span class="token keyword">go</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// create a new goroutine that calls f(); don&#39;t wait</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_8-2-示例-并发的clock服务" tabindex="-1"><a class="header-anchor" href="#_8-2-示例-并发的clock服务"><span>8.2. 示例: 并发的Clock服务</span></a></h2>`,7),k={href:"https://golang-china.github.io/gopl-zh/ch8/ch8-02.html",target:"_blank",rel:"noopener noreferrer"},m=s(`<p>网络编程是并发大显身手的一个领域，由于服务器是最典型的需要同时处理很多连接的程序，这些连接一般来自于彼此独立的客户端。</p><p>在本小节中，我们会讲解go语言的net包，这个包提供编写一个网络客户端或者服务器程序的基本组件，无论两者间通信是使用TCP、UDP或者Unix domain sockets。</p><p>在第一章中我们使用过的net/http包里的方法，也算是net包的一部分。</p><p>我们的第一个例子是一个顺序执行的时钟服务器，它会每隔一秒钟将当前时间写到客户端：</p><p><code>gopl.io/ch8/clock1</code></p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// Clock1 is a TCP server that periodically writes the time.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">&quot;io&quot;</span>
    <span class="token string">&quot;log&quot;</span>
    <span class="token string">&quot;net&quot;</span>
    <span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    listener<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">&quot;tcp&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;localhost:8000&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> listener<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token comment">// e.g., connection aborted</span>
            <span class="token keyword">continue</span>
        <span class="token punctuation">}</span>
        <span class="token function">handleConn</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span> <span class="token comment">// handle one connection at a time</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">handleConn</span><span class="token punctuation">(</span>c net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">defer</span> c<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> io<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">&quot;15:04:05\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token comment">// e.g., client disconnected</span>
        <span class="token punctuation">}</span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>Listen函数创建了一个 <code>net.Listener</code> 的对象，这个对象会监听一个网络端口上到来的连接，在这个例子里我们用的是TCP的 <code>localhost:8000</code>端口。listener对象的Accept方法会直接阻塞，直到一个新的连接被创建，然后会返回一个net.Conn对象来表示这个连接。</p></li><li><p>handleConn函数会处理一个完整的客户端连接。在一个for死循环中，用time.Now()获取当前时刻，然后写到客户端。由于net.Conn实现了io.Writer接口，我们可以直接向其写入内容。这个死循环会一直执行，直到写入失败。最可能的原因是客户端主动断开连接。这种情况下handleConn函数会用defer调用关闭服务器侧的连接，然后返回到主函数，继续等待下一个连接请求。</p></li><li><p><code>time.Time.Format</code> 方法提供了一种格式化日期和时间信息的方式。它的参数是一个格式化模板，标识如何来格式化时间，而这个格式化模板限定为 <code>Mon Jan 2 03:04:05PM 2006 UTC-0700</code>。有8个部分（周几、月份、一个月的第几天……）。可以以任意的形式来组合前面这个模板；出现在模板中的部分会作为参考来对时间格式进行输出。</p><p>在上面的例子中我们只用到了小时、分钟和秒。time包里定义了很多标准时间格式，比如 <code>time.RFC1123</code>。</p><p>在进行格式化的逆向操作 <code>time.Parse</code> 时，也会用到同样的策略。（译注：这是go语言和其它语言相比比较奇葩的一个地方。你需要记住格式化字符串是1月2日下午3点4分5秒零六年UTC-0700，而不像其它语言那样 <code>Y-m-d H:i:s</code> 一样，当然了这里可以用1234567的方式来记忆，倒是也不麻烦。）</p></li></ul><p>为了连接例子里的服务器，我们需要一个客户端程序，比如netcat这个工具（nc命令），这个工具可以用来执行网络连接操作。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>$ go build gopl.io/ch8/clock1
$ ./clock1 &amp;
$ nc localhost 8000
13:58:54
13:58:55
13:58:56
13:58:57
^C
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://cdn.ayusummer233.top/DailyNotes/image-20240618163750385.png" alt="image-20240618163750385"></p><p>客户端将服务器发来的时间显示了出来，我们用Control+C来中断客户端的执行，在Unix系统上，你会看到^C这样的响应。如果你的系统没有装nc这个工具，你可以用telnet来实现同样的效果，或者也可以用我们下面的这个用go写的简单的telnet程序，用net.Dial就可以简单地创建一个TCP连接：</p><p><code>gopl.io/ch8/netcat1</code></p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// Netcat1 is a read-only TCP client.</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">&quot;io&quot;</span>
    <span class="token string">&quot;log&quot;</span>
    <span class="token string">&quot;net&quot;</span>
    <span class="token string">&quot;os&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">&quot;tcp&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;localhost:8000&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">mustCopy</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> conn<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">mustCopy</span><span class="token punctuation">(</span>dst io<span class="token punctuation">.</span>Writer<span class="token punctuation">,</span> src io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> io<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个程序会从连接中读取数据，并将读到的内容写到标准输出中，直到遇到end of file的条件或者发生错误。mustCopy这个函数我们在本节的几个例子中都会用到。让我们同时运行两个客户端来进行一个测试，这里可以开两个终端窗口，下面左边的是其中的一个的输出，右边的是另一个的输出：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>$ go build gopl.io/ch8/netcat1
$ ./netcat1
13:58:54                               $ ./netcat1
13:58:55
13:58:56
^C
                                       13:58:57
                                       13:58:58
                                       13:58:59
                                       ^C
$ killall clock1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>killall命令是一个Unix命令行工具，可以用给定的进程名来杀掉所有名字匹配的进程。</p><p>第二个客户端必须等待第一个客户端完成工作，这样服务端才能继续向后执行；因为我们这里的服务器程序同一时间只能处理一个客户端连接。我们这里对服务端程序做一点小改动，使其支持并发：在handleConn函数调用的地方增加go关键字，让每一次handleConn的调用都进入一个独立的goroutine。</p><p><em>gopl.io/ch8/clock2</em></p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">for</span> <span class="token punctuation">{</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> listener<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token comment">// e.g., connection aborted</span>
        <span class="token keyword">continue</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">go</span> <span class="token function">handleConn</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span> <span class="token comment">// handle connections concurrently</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在多个客户端可以同时接收到时间了：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>$ go build gopl.io/ch8/clock2
$ ./clock2 &amp;
$ go build gopl.io/ch8/netcat1
$ ./netcat1
14:02:54                               $ ./netcat1
14:02:55                               14:02:55
14:02:56                               14:02:56
14:02:57                               ^C
14:02:58
14:02:59                               $ ./netcat1
14:03:00                               14:03:00
14:03:01                               14:03:01
^C                                     14:03:02
                                       ^C
$ killall clock2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://cdn.ayusummer233.top/DailyNotes/image-20240618164234113.png" alt="image-20240618164234113"></p><p><img src="http://cdn.ayusummer233.top/DailyNotes/image-20240618164329406.png" alt="image-20240618164329406"></p><hr><p><strong>练习 8.1：</strong> 修改clock2来支持传入参数作为端口号，然后写一个clockwall的程序，这个程序可以同时与多个clock服务器通信，从多个服务器中读取时间，并且在一个表格中一次显示所有服务器传回的结果，类似于你在某些办公室里看到的时钟墙。如果你有地理学上分布式的服务器可以用的话，让这些服务器跑在不同的机器上面；或者在同一台机器上跑多个不同的实例，这些实例监听不同的端口，假装自己在不同的时区。像下面这样：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token assign-left variable">TZ</span><span class="token operator">=</span>US/Eastern    ./clock2 <span class="token parameter variable">-port</span> <span class="token number">8010</span> <span class="token operator">&amp;</span>
$ <span class="token assign-left variable">TZ</span><span class="token operator">=</span>Asia/Tokyo    ./clock2 <span class="token parameter variable">-port</span> <span class="token number">8020</span> <span class="token operator">&amp;</span>
$ <span class="token assign-left variable">TZ</span><span class="token operator">=</span>Europe/London ./clock2 <span class="token parameter variable">-port</span> <span class="token number">8030</span> <span class="token operator">&amp;</span>
$ clockwall <span class="token assign-left variable">NewYork</span><span class="token operator">=</span>localhost:8010 <span class="token assign-left variable">Tokyo</span><span class="token operator">=</span>localhost:8020 <span class="token assign-left variable">London</span><span class="token operator">=</span>localhost:8030
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://cdn.ayusummer233.top/DailyNotes/image-20240618165157657.png" alt="image-20240618165157657"></p><p><img src="http://cdn.ayusummer233.top/DailyNotes/image-20240618165336246.png" alt="image-20240618165336246"></p><hr><p><strong>练习 8.2：</strong> 实现一个并发FTP服务器。服务器应该解析客户端发来的一些命令，比如cd命令来切换目录，ls来列出目录内文件，get和send来传输文件，close来关闭连接。你可以用标准的ftp命令来作为客户端，或者也可以自己实现一个。</p><hr><p>QA: 关于只读和只写CHannel的描述</p>`,32);function v(g,b){const a=i("ExternalLinkIcon");return p(),l("div",null,[u,n("blockquote",null,[n("p",null,[n("a",r,[e("Goroutines - Go语言圣经 (golang-china.github.io)"),t(a)])])]),d,n("blockquote",null,[n("p",null,[n("a",k,[e("示例: 并发的Clock服务 - Go语言圣经 (golang-china.github.io)"),t(a)])])]),m])}const C=o(c,[["render",v],["__file","CH8-Goroutines和Channels.html.vue"]]),y=JSON.parse('{"path":"/Language/Go/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/CH8-Goroutines%E5%92%8CChannels.html","title":"CH8.Goroutines和Channels","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"8.1.Goroutines","slug":"_8-1-goroutines","link":"#_8-1-goroutines","children":[]},{"level":2,"title":"8.2. 示例: 并发的Clock服务","slug":"_8-2-示例-并发的clock服务","link":"#_8-2-示例-并发的clock服务","children":[]}],"git":{"createdTime":1719188604000,"updatedTime":1719188604000,"contributors":[{"name":"233JG","email":"ayusummer233@gmail.com","commits":1}]},"readingTime":{"minutes":10.7,"words":3210},"filePathRelative":"Language/Go/Go语言圣经/CH8-Goroutines和Channels.md","localizedDate":"2024年6月24日","excerpt":"\\n<ul>\\n<li><a href=\\"#ch8goroutines%E5%92%8Cchannels\\">CH8.Goroutines和Channels</a>\\n<ul>\\n<li><a href=\\"#%E7%AE%80%E4%BB%8B\\">简介</a></li>\\n<li><a href=\\"#81goroutines\\">8.1.Goroutines</a></li>\\n<li><a href=\\"#82-%E7%A4%BA%E4%BE%8B-%E5%B9%B6%E5%8F%91%E7%9A%84clock%E6%9C%8D%E5%8A%A1\\">8.2. 示例: 并发的Clock服务</a></li>\\n</ul>\\n</li>\\n</ul>"}');export{C as comp,y as data};
